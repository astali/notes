
CPU过载不再是杀死重启，定位问题原因，解决问题
###问：如何定位是哪个服务进程导致CPU过载，哪个线程导致CPU过载，哪段代码导致CPU过载？
**第一步:找到最耗CPU进程**
-   执行`top -c` 显示线程运行列表
-   执行 `P`  进程按照CPU使用率排序
   假如:最耗CPU的进程PID为10765

**第二步:找到最耗CPU的线程**
- 执行`top -Hp 10765` 显示一个进程的线程运行信息列表
- 执行 `P`  进程按照CPU使用率排序
     假如:最耗CPU的线程PID为10804

**第三步:将线程PID转化为16进制**
 - 执行 `printf “%x\n” 10804`    转化为16进制是因为堆栈里，线程id是用16进制表示的。
  假如10804对应的16进制是0x2a34

**步骤四：查看堆栈，找到线程在干嘛**
 - 执行`jstack 10765 | grep '0x2a34' -C5 --color`  打印进程堆栈 ，通过线程id，过滤得到线程堆栈
   找到了耗CPU高的线程对应的线程名称”testAsyncLogger-1”，以及看到了该线程正在执行代码的堆栈。