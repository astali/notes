  **使用Lua脚本的好处**

​       **1、减少网络开销：可以将多个请求通过脚本的形式一次发送，减少网络时延和请求次数。**

​       **2、原子性的操作：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务。**

​       **3、代码复用：客户端发送的脚步会永久存在redis中，这样，其他客户端可以复用这一脚本来完成相同的逻辑。**

​       **4、速度快：见 与其它语言的性能比较, 还有一个 JIT编译器可以显著地提高多数任务的性能; 对于那些仍然对性能不满意的人, 可以把关键部分使用C实现, 然后与其集成, 这样还可以享受其它方面的好处。**

​       **5、可以移植：只要是有ANSI C 编译器的平台都可以编译，你可以看到它可以在几乎所有的平台上运行:从 Windows 到Linux，同样Mac平台也没问题, 再到移动平台、游戏主机，甚至浏览器也可以完美使用 (翻译成JavaScript).**

​       **6、源码小巧：20000行C代码，可以编译进182K的可执行文件，加载快，运行快。**  

注意：
    **1、Lua脚本可以在redis单机模式、主从模式、Sentinel集群模式下正常使用，但是无法在分片集群模式下使用。（脚本操作的key可能不在同一个分片）**
    **2、Lua脚本中尽量避免使用循环操作（可能引发死循环问题），尽量避免长时间运行。**

​    **3、redis在执行lua脚本时，默认最长运行时间时5秒，当脚本运行时间超过这一限制后，Redis将开始接受其他命令但不会执行（以确保脚本的原子性，因为此时脚本并没有被终止），而是会返回“BUSY”错误。**





./redis-cli --eval  /tmp/luatest.lua rate.limitingl:127.0.0.1 , "a" "b"



## Redis-Lua实现抢红包逻辑

**1、判断是否存在可抢的库存，如果己经没有可抢夺 的红包，则返回为 0，结束流程**
**2、有可抢夺的红包，对于红包的库存减1 ，然后重新设置库存**
**3、将抢红包数据保存到 Redis 的链表当中，链表的 key 为 red_packet_list_ {id｝**
**4、如果当前库存为 0 ，那么返回 2，这说明可以触发数据库对 Redis 链表数据的保存，链表的 key 为 red_packet_ list_ {id｝，它将保存抢红包的用户名和抢的时间**

**5、如果当前库存不为 0 ，那么将返回 1，这说明抢红包信息保存成功。**

