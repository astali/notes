# [Dubbo面试踩坑](https://www.cnblogs.com/lxyit/p/9035094.html)

#### 1.Dubbo支持哪些协议，每种协议的应用场景，优缺点？

- **dubbo：** 单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP，异步，Hessian序列化；
- **rmi：** 采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。 多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞；
- **webservice：** 基于WebService的远程调用协议，集成CXF实现，提供和原生WebService的互操作。多个短连接，基于HTTP传输，同步传输，适用系统集成和跨语言调用；
- **http：** 基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用；
- **hessian：** 集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；
- **memcache：** 基于memcached实现的RPC协议
- **redis：** 基于redis实现的RPC协议

#### 2.Dubbo超时时间怎样设置？

　Dubbo超时时间设置有两种方式：

- 服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。
- 服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。

#### 3.Dubbo有些哪些注册中心？

- **Multicast注册中心：** Multicast注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现；
- **Zookeeper注册中心：** 基于分布式协调系统Zookeeper实现，采用Zookeeper的watch机制实现数据变更；
- **redis注册中心：** 基于redis实现，采用key/Map存储，住key存储服务名和类型，Map中key存储服务URL，value服务过期时间。基于redis的发布/订阅模式通知数据变更；
- **Simple注册中心**

#### 4.Dubbo集群的负载均衡有哪些策略　　

　Dubbo提供了常见的集群策略实现，并预扩展点予以自行实现。

- **Random LoadBalance:** 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；
- **RoundRobin LoadBalance:** 轮循选取提供者策略，平均分布，但是存在请求累积的问题；
- **LeastActive LoadBalance:** 最少活跃调用策略，解决慢提供者接收更少的请求；
- **ConstantHash LoadBalance:** 一致性Hash策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；

 **zookeeper是如何保证事务的顺序一致性的** 
zookeeper采用了递增的事务Id来标识，所有的proposal都在被提出的时候加上了zxid，zxid实际上是一个64位的数字，高32位是epoch用来标识leader是否发生改变，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行 

1.同时配置了XML和properties文件，则properties中的配置无效，只有XML没有配置时，properties才生效。

 

2.dubbo缺省会在启动时检查依赖是否可用，不可用就抛出异常，阻止spring初始化完成，check属性默认为true。测试时有些服务不关心或者出现了循环依赖，将check设置为false

 

3.为了方便开发测试，线下有一个所有服务可用的注册中心，这时，如果有一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。解决：让服务提供者开发方，只订阅服务，而不注册正在开发的服务，通过直连测试正在开发的服务。设置dubbo:registry标签的register属性为false。

 

4.spring 2.x初始化死锁问题。在spring解析到dubbo:service时，就已经向外暴露了服务，而spring还在接着初始化其他bean，如果这时有请求进来，并且服务的实现类里有调用applicationContext.getBean()的用法。getBean线程和spring初始化线程的锁的顺序不一样，导致了线程死锁，不能提供服务，启动不了。

解决：不要在服务的实现类中使用applicationContext.getBean();如果不想依赖配置顺序，可以将dubbo:provider的deplay属性设置为-1，使dubbo在容器初始化完成后再暴露服务。

 

**5.服务注册不上**

检查dubbo的jar包有没有在classpath中，以及有没有重复的jar包

检查暴露服务的spring配置有没有加载

在服务提供者机器上测试与注册中心的网络是否通

 

**6.出现RpcException: No provider available for remote service异常怎么办？**

表示没有可用的服务提供者，

1). 检查连接的注册中心是否正确

2). 到注册中心查看相应的服务提供者是否存在

3). 检查服务提供者是否正常运行

 

**7.出现"消息发送失败"异常怎么办？**

通常是接口方法的传入传出参数未实现Serializable接口。

 

**8.SpringCloud和Dubbo的比较**

相同点：都能提供服务注册，调用，监控

spring cloud提供了一整套企业级分布式云应用的完美解决方案，能够结合spring boot,docker实现快速开发的目的,核心要素在于服务的发现，注册，路由，熔断降级，分布式配置，dubbo只有spring cloud的一部分rpc的功能服务治理

spring cloud的服务调用方式是rest api,可以跨平台，dubbo的服务调用方式是RPC,默认不能跨平台，需要实现一层代理，以rest方式提供对外服务。

spring cloud的常用服务注册中心是zookeeper，spring cloud常用服务注册中心是spring cloud netflix eureka

spring cloud的服务监控是spring boot admin, dubbo的服务监控是dubbo-monitor

 

**9.为什么选择dubbo**

提供了远程通讯，对多种基于单一长连接的NIO框架抽象封装，适用于小数据量，大并发的服务调用，如果数据量较大，可以使用多个连接。

提供了负载均衡和容错机制

服务自动注册与发现

与spring集成配置简单

支持多种协议，默认TCP协议

**10.为什么消者比提供者个数多？**

dubbo采用单一长连接，根据测算经验数据，每条连接最多只能压满7M，理论上1个服务提供者需要20个消费者才能压满网卡。



**11.为什么采用单一长连接**

服务大多数服务提供者少，服务的消费者多，单一连接保证单一消费者不会压死提供者，长连接减少连接握手频率，节省资源。

**12.为防止大量连接撑挂，可在服务提供方限制大接收连接数，以实现服务提供方自我保护，即设置**dubbo:protocol中accept属性

13. **测试和生产公用一套zookeeper，怎么保证消费不冲突**

可以通过自定义filter实现filter接口来实现dubbo接口的ip白名单，限制访问权限。

**14.如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？**

可以通信，启动dubbo时，消费者会从zk拉去注册的生产者的地址接口作为数据，缓存在本地，每次调用安装本地的缓存地址进行调用。

15.服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务提供者恢复。

16.注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了服务提供者列表，服务消费者可以直连提供者。

17.dubbo在安全机制方面如何解决的？

dubbo通过token令牌防止用户绕过注册中心直连，然后在注册中心管理授权，dubbo提供了黑白名单，控制服务所允许的调用方。

18.hession序列化失败hessionruntimeexception

检查服务方法传入传出参数是否实现serializable接口



19.rejectedExecutionexception异常

线程池到达最大值，在dubbo.properties中增加线程池最大值和最小值大小

 

```
20 .RpcLocalExceptionIoTargetIsNotConnected
```

检查注册中心是否开启白名单功能，如果开启了，当ip不在白名单列表中，注册中心拒绝连接。

检查端口是否正确，注册中心有2个端口，一个为控制台http端口，用于管理员查看数据，一个为程序注册服务用的tcp端口。

 

**21.dubbo服务发布过程做了哪些事**

暴露本地服务，暴露远程服务，启动netty，连接zookeeper，到zookeeper注册，监听zookeeper

 

**22.dubbo有哪些协议，他们之间有什么特点**

dubbo允许配置多协议，不同服务不同协议，大数据用短连接协议，小数据大并发用长连接协议。

 

23.什么是本地暴露和远程暴露，他们的区别

本地暴露：一个服务可能既是provider，又是consumer，自己调用自己的服务，暴露在jvm中，不需要网络通信。url是以injvm开头

远程暴露：将ip，端口等信息暴露给远程客户端，调用时需要网络通信。

dubbo处理服务暴露的关键在于Invoker转换到Exporter的过程。



**关于dubbo是用的什么协议？**

在使用dubbo的时候会配置<dubbo:protocolname="dubbo"port="20880"/>所以再回答面试官的时候就随口说的是dubbo协议，其实面试官问的此协议非彼协议，而是问的是http协议还是Tcp协议，因为dubbo的核心就是用的单一长连接进行异步通信。

​      那问题来了为什么要用dubbo进行数据传输？

​      一般服务端服务器比较少，消费端有可能会有很多项目或者工程会调用dubbo的接口，而且数据量传输较小且并发量比较高的情况下用dubbo效率会很高。

 Tcp协议就是所谓的长连接

 HTTP协议呢就是所谓的短连接，经典的三次握手。

长连接的好处：

减少来回握手的频率，当操作频繁，点对点的通讯时，可以同时发送多个数据包，以不至于服务者被消费者压死

**Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？** 

可以

1.启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。
2.注册中心对等集群，任意一台宕掉后，会自动切换到另一台 。
3.注册中心全部宕掉，服务提供者和消费者仍可以通过本地缓存通讯 。
4.服务提供者无状态，任一台 宕机后，不影响使用 。
5.服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复 。

**2、dubbo连接注册中心和直连的区别 ？**
在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连， 点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，服务注册中心，动态的注册和发现服务，使服务的位置透明，并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover， 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 

服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外，注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者，注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表，注册中心和监控中心都是可选的，服务消费者可以直连服务提供者

**3、Dubbo在安全机制方面是如何解决的 ？**
Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。




